class UF {
public:  
	vector<int> id;
	vector<int> sz;
	
	UF(int len) {
		id.resize(len);
		sz.resize(len);
		for (int i = 0; i < len; ++i) {
			id[i] = i;
			sz[i] = 1;
		}
	}
	
	int find(int p) {
		while (id[p] != p) p = id[p];
		
		return id[p];
	}
	
	bool isConnected(int p, int q) {
		return p == q || find(p) == find(q);
	}
	
	void unite(int p, int q) {
		int rp = find(p), rq = find(q);
		if (rp == rq) return;
		
		if(sz[rp] >= sz[rq]) {
			id[rq] = rp;
			sz[rp] += sz[rq];
			sz[rq] = 0;
		}
		else {
			id[rp] = rq;
			sz[rq] += sz[rp];
			sz[rp] = 0;
		}
	}
	
};

class Solution {
public:
	int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
		size_t len = graph.size();
		UF uf(len);     
		for (int i = 0; i < len; ++i) {
			for (int j = 0; j < len; ++j) {
				if (graph[i][j] == 1 && i != j) {
					if (uf.isConnected(i, j)) continue;
					
					if (i < j) {
						uf.unite(i, j);
					}
					else {
						uf.unite(j, i);
					}
				}
			}
		}
		
		sort(initial.begin(), initial.end());

		int maxSize(0);
		int maxNode(initial[0]);
		for (auto i : initial) {
			int currSize = uf.sz[ uf.find(i) ];
			if (currSize > maxSize) {
				maxSize = currSize;
				maxNode = i;
			}
		}
		
		return maxNode;
	}
};